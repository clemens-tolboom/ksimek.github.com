---
layout: post
title: "Dissecting the Camera Matrix, Part 1: Extrinsic/Intrinsic Decomposition"
description: ""
---

<script type="text/javascript" src="/js/geometry/FocalPlaneGeometry.js"></script>
<script type="text/javascript" src="/js/geometry/FrustumGeometry.js"></script>


<script>
    $(document).ready(function(){
        var $container;
    // attach the render-supplied DOM element


        $container = $('#3d_container');
        
        var clock = new THREE.Clock();
        var revolve_t = 0;
        var REVOLVE_PERIOD = 10;
        var REVOLVE_RADIUS = 400;
        var x0, y0, s, fx, fy;
        var rot_y, tx, ty, tz;

        // set the scene size
        var parent_width = $('#3d_container').parent().width();
        var WIDTH = parent_width/2,
          HEIGHT = 2/3*WIDTH;

        // set some camera attributes
        var VIEW_ANGLE = 45,
          ASPECT = WIDTH / HEIGHT,
          NEAR = 50,
          FAR = 10000;

        // get the DOM element to attach to
        // - assume we've got jQuery to hand

        // create a WebGL renderer, camera
        // and a scene
        var renderer = new THREE.WebGLRenderer();
        // start the renderer
        renderer.setSize(WIDTH*2, HEIGHT);
        renderer.autoClear = false;
        $container.prepend(renderer.domElement);

        var scene = new THREE.Scene();
        var camera_scene = new THREE.Scene();

    //    var renderer = new THREE.CanvasRenderer();

        var default_focal = HEIGHT / 2 / Math.tan(VIEW_ANGLE/2 * Math.PI / 360);
        var FOCAL_MIN = default_focal / 2;
        var FOCAL_MAX = default_focal * 2;
        var SKEW_MIN = 0.0;
        var SKEW_MAX = HEIGHT;
        var X0_MIN = -WIDTH/2;
        var X0_MAX =  WIDTH/2;
        var Y0_MIN = -HEIGHT/2;
        var Y0_MAX =  HEIGHT/2;

        var camera =
          new THREE.CalibratedCamera(
            default_focal, default_focal,
            0, 0,
            0,
            WIDTH,
            HEIGHT,
            NEAR,
            FAR);
    //    camera.matrixAutoUpdate = false;
        camera.updateProjectionMatrix();

        //camera.rotation.y = 0.3;
        camera.rotation.y = 0.1;

        // the camera starts at 0,0,0
        // so pull it back
        camera.position.z = 300;
        camera.updateMatrix();

        // add the camera to the scene
        scene.add(camera);
        camera_scene.add(camera);


        
        // camera frustum
        var frustum_far = FOCAL_MAX;
        var frustum_material =
            new THREE.MeshBasicMaterial( { color: 0x666666, wireframe: true } );
//        var frustum = new THREE.Mesh(
//                camera.makeFrustumGeometry(0, frustum_far),
//                frustum_material
//                );
        var frustum = new THREE.Mesh(
                new THREE.FrustumGeometry(0, frustum_far, camera),
                frustum_material
                );
        camera_scene.add(frustum);

        var focal_plane_material = new THREE.MeshBasicMaterial({color: 0xEEEE00, transparent: true, opacity: 0.5});
        var focal_plane = new THREE.Mesh(
                new THREE.FocalPlaneGeometry(camera),
                focal_plane_material);
        focal_plane.doubleSided = true;

        camera_scene.add(focal_plane);

        var cameraCubeMaterial = new THREE.MeshBasicMaterial({color: 0x0000bb});
        var cameraCube = new THREE.Mesh(
              new THREE.CubeGeometry(
                75/2,
                75/2,
                37.5/2),
              cameraCubeMaterial);
        cameraCube.position = camera.position;
        cameraCube.rotation = camera.rotation;
        camera_scene.add(cameraCube);

        // set up the sphere vars
        var radius = 50,
            segments = 16,
            rings = 16;

        // create the sphere's material
        var sphereMaterial =
          new THREE.MeshLambertMaterial(
            {
              color: 0xCC0000
            });

        var sphere2Material =
          new THREE.MeshLambertMaterial(
            {
              color: 0x00CC00
            });

        var sphere = new THREE.Mesh(

          new THREE.SphereGeometry(
            radius,
            segments,
            rings),

          sphereMaterial);

        var sphere2 = new THREE.Mesh(

          new THREE.SphereGeometry(
            radius,
            segments,
            rings),

          sphere2Material);

        sphere2.position.z -= 100;
        sphere2.position.x -= 100;

        // add the sphere to the scene
        scene.add(sphere);
        scene.add(sphere2);

        // OVERHEAD VIEW
        var SCENE_HEIGHT = 1.5 * (camera.position.z - sphere2.position.z);
        var SCENE_WIDTH = SCENE_HEIGHT * ASPECT;
        var scale = 4.0;
        var overhead_camera = 
          new THREE.OrthographicCamera(
            SCENE_WIDTH / - 2,
            SCENE_WIDTH / 2,
            SCENE_HEIGHT / 2,
            SCENE_HEIGHT / - 2,
            -2000, 2000);
        overhead_camera.position.x = 0;
        overhead_camera.position.y = 300;
        overhead_camera.position.z = 0;

        overhead_camera.rotation.x =- 0.8;


        scene.add(overhead_camera);

        // OVERLAY: Camera for drawing 2D elements
        var overlay_scene = new THREE.Scene();
        var overlay_camera =
          new THREE.OrthographicCamera(
            WIDTH / - 2,
            WIDTH / 2,
            HEIGHT / 2,
            HEIGHT / - 2,
            -100, 100);

        var line_material = new THREE.MeshBasicMaterial({color: 0xbbbbbb, wireframe:true});
        var vertical_line = new THREE.Mesh( new THREE.PlaneGeometry(HEIGHT, 1), line_material);
        vertical_line.position.z = 0; 
        vertical_line.rotation.z = Math.PI/2;
        overlay_scene.add(overlay_camera);
        overlay_scene.add(vertical_line);

        // create a point light
        var pointLight =
          new THREE.PointLight(0xFFFFFF);

        // set its position
        pointLight.position.x = 10;
        pointLight.position.y = 50;
        pointLight.position.z = 130;

        // add to the scene
        scene.add(pointLight);

//        function (width, height, near, far, focal_length) 
//        {
//            near = near !== undefined ? near : this.near;
//            far = far !== undefined ? far : this.far;
//
//            var frustum_depth = far - near;
//            var frustum_geom = new THREE.CubeGeometry(this.width, this.height, frustum_depth);
//
//            for(var i = 0; i < geom.vertices.length; ++i)
//            {
//                geom.vertices[i].z += frustum_depth/2 + near;
//                var z = geom.vertices[i].z;
//
//                geom.vertices[i].x *= z;
//                geom.vertices[i].y *= z;
//            }
//
//            var focal_plane = new THREE.Mesh();
//                    new THREE.MeshBasicMaterial({color: 0xEEEE00, transparent: true, opacity: 0.5}));
//            focal_plane.doubleSided = true;
//
//            focal_plane.rotation.x = Math.PI/2;
//            focal_plane.position.z = -camera.fx;
//            focal_plane_pose.rotation = camera.rotation;
//            focal_plane_pose.position = camera.position;
//            focal_plane_pose.add(focal_plane);
//            scene.add(focal_plane_pose);
//
//
//
//            var tm = this.toIntrinsicMatrix();
//            tm.elements[10] = -1;
//            tm.elements[11] = 0;
//            tm.elements[12] = 0;
//            tm.elements[13] = 0;
//            tm.elements[14] = 0;
//            tm.elements[15] = 1;
//
//            tm.getInverse(tm.clone());
//
//            frustum_geom.applyMatrix(tm);
//            focal_plane_geom.applyMatrix(tm);
//
//            this.updateMatrix();
//            frustum_geom.applyMatrix(this.matrix);
//            focal_plane_geom.applyMatrix(tm);
//            return geom;
//        }

        function updateDemo()
        {
            camera.updateMatrix();
            camera.updateProjectionMatrix();
            camera_scene.remove(focal_plane);
            camera_scene.remove(frustum);

            frustum = new THREE.Mesh(
                new THREE.FrustumGeometry(0, frustum_far, camera),
                frustum_material
                );

            focal_plane = new THREE.Mesh(
                    new THREE.FocalPlaneGeometry(camera),
                    focal_plane_material);
            focal_plane.doubleSided = true;

            camera_scene.add(focal_plane);
            camera_scene.add(frustum);
            render();
        }

        function render()
        {
            renderer.clear();
            renderer.setViewport(WIDTH,0,WIDTH, HEIGHT);
            renderer.render(scene, camera);

            renderer.setViewport(0,0,WIDTH, HEIGHT);
            renderer.render(scene, overhead_camera);
            renderer.render(camera_scene, overhead_camera);

            renderer.setViewport(0,0,WIDTH*2, HEIGHT);
            renderer.render(overlay_scene, overlay_camera);
        }

        function animate() {

            requestAnimationFrame( animate );
            revolve_t += clock.getDelta();
            revolve_t = REVOLVE_PERIOD / 8;
            while(revolve_t > REVOLVE_PERIOD)
                revolve_t -= REVOLVE_PERIOD;
            overhead_camera.rotationAutoUpdate = true;
            overhead_camera.position.x = REVOLVE_RADIUS * Math.cos(revolve_t/REVOLVE_PERIOD * 2*Math.PI);
            overhead_camera.position.z = REVOLVE_RADIUS * Math.sin(revolve_t/REVOLVE_PERIOD * 2*Math.PI);
            overhead_camera.lookAt(new THREE.Vector3(0,0,-200));
            
            render();

        }



        var focal_slider = $('#focal_slider');
        focal_slider.slider({
            value: camera.fx,
            min: FOCAL_MIN,
            max: FOCAL_MAX,
            slide: function(event, ui) {
                camera.fx = ui.value;
                camera.fy = camera.fx;
                focal_plane.position.z = -camera.fx;
                updateDemo();
                return true;
            }
        });

        var skew_slider = $('#skew_slider');
        skew_slider.slider({
            value: camera.s,
            min: SKEW_MIN,
            max: SKEW_MAX,
            step: 0.01,
            slide: function(event, ui) {
                camera.s = ui.value;
                updateDemo();
                return true;
            }
        });

        var x0_slider = $('#x0_slider');
        x0_slider.slider({
            value: camera.x0,
            min: X0_MIN,
            max: X0_MAX,
            slide: function(event, ui) {
                camera.x0 = ui.value;
                updateDemo();
                return true;
            }
        });

        var y0_slider = $('#y0_slider');
        y0_slider.slider({
            value: camera.y0,
            min: Y0_MIN,
            max: Y0_MAX,
            slide: function(event, ui) {
                camera.y0 = ui.value;
                updateDemo();
                return true;
            }
        });



        render();
        animate();
    });

</script>

Lorem ipsum...


<h2>The Extrinsic Camera Matrix</h2>

The camera's extrinsic matrix describes the camera's location in the world, and what direction it's pointing.  Those familiar with OpenGL know this as the "View matrix" (or more loosely, the "Modelview matrix").  It has two components: a rotation matrix, *R*, and a translation vector ***t***, which, as we'll soon see, don't exactly correspond to the camera's rotation and translation.  First we'll examine the parts of the extrinsic matrix, and later we'll look at alternative ways of describing the camera's pose that are more intuitive.

The extrinsic matrix takes the form of a rigid transformation matrix: a 3x3 rotation matrix in the left-block, and 3x1 translation column-vector in the right:

<div>
\[ [ R | \boldsymbol{t}] = 
\left[ \begin{array}{ccc|c} 
r_{1,1} & r_{1,2} & r_{1,3} & t_1 \\
r_{2,1} & r_{2,2} & r_{2,3} & t_2 \\
r_{3,1} & r_{3,2} & r_{3,3} & t_3 \\
\end{array} \right] \]
</div>

We may further decompose this matrix into a rotation _followed by_ a translation:

<div>
\[ [ R | \boldsymbol{t}] = [\boldsymbol{I} | \boldsymbol{t}] \times [R | \boldsymbol{0}] = 
\left[ \begin{array}{ccc|c} 
1 & 0 & 0 & t_1 \\
0 & 1 & 0 & t_2 \\
0 & 0 & 1 & t_3 \\
\end{array} \right] \times
\left[ \begin{array}{ccc|c} 
r_{1,1} & r_{1,2} & r_{1,3} & 0  \\
r_{2,1} & r_{2,2} & r_{2,3} & 0 \\
r_{3,1} & r_{3,2} & r_{3,3} & 0 \\
\end{array} \right] 
 \]
</div>

This matrix describes how to transform points in world coordinates to camera coordinates.  The vector ***t*** can be interpreted as the position of the world origin in camera coordinates, and the columns of R represent represent the directions of the world-axes in camera coordinates.

The important thing to remember about the extrinsic matrix is that it describes how the _world_ is transformed relative to the _camera_.  This is often counter-intuitive, because we usually want to specify how the _camera_ is transformed relative to the _world_.    Next, we'll examine two alternative ways to describe the camera's extrinsic parameters that are more intuitive, and how to convert them into the form of an extrinsic matrix.

<h2>Building the Extrinsic Matrix from Camera Pose</h2> 
It's often more natural to specify the camera's pose directly rather than specifying how world points should transform to camera coordinates.  Luckilly, building an extrinsic camera matrix this way is easy: just build a rigid transformation matrix that describes the camera's pose and then take it's inverse.

Let *C* be a column vector describing the location of the camera-center in world coordinates, and let \\(R_c\\) be the rotation matrix describing the camera's orientation with respect to the world coordinate axes.  The transformation matrix that describes the camera's pose is then given by \\([R_c | C ]\\).  We need to invert this matrix to get the extrinsic camera matrix, and in order to make this matrix invertible, we first make it square by adding an extra row of (0,0,0,1).  Then the extrinsic matrix is given by:

<div>
\begin{align}
\left (
\begin{array}{c|c}
R & \boldsymbol{t} \\
\hline \\
\boldsymbol{0} & 1 \\
\end{array}
\right )
  &= 
\left (
\begin{array}{c|c}
R_c & C \\
\hline \\
\boldsymbol{0} & 1 \\
\end{array}
\right )^{-1} \\
  &= 
\left (

\left (
\begin{array}{c|c}
I & C \\
\hline \\
\boldsymbol{0} & 1 \\
\end{array}
\right )

\left (
\begin{array}{c|c}
R_c & 0 \\
\hline \\
\boldsymbol{0} & 1 \\
\end{array}
\right )
\right )^{-1} & \text{(decomposing rigid transform)} \\
&= 
\left (
\begin{array}{c|c}
R_c & 0 \\
\hline \\
\boldsymbol{0} & 1 \\
\end{array}
\right )^{-1} 
\left (
\begin{array}{c|c}
I & C \\
\hline \\
\boldsymbol{0} & 1 \\
\end{array}
\right )^{-1} & \text{(distributing the inverse)}\\
&= 
\left (
\begin{array}{c|c}
R_c^T & 0 \\
\hline \\
\boldsymbol{0} & 1 \\
\end{array}
\right )
\left (
\begin{array}{c|c}
I & -C \\
\hline \\
\boldsymbol{0} & 1 \\
\end{array}
\right ) & \text{(applying the inverse)}\\
&= 
\left (
\begin{array}{c|c}
R_c^T & -R_c^TC \\
\hline \\
\boldsymbol{0} & 1 \\
\end{array}
\right ) & \text{(matrix multiplication)}
\end{align} 
</div>

Thus, we see that the relationship between the extrinsic matrix parameters and the camera's pose is straightforward:

<div>
\[
\begin{align}
R  &= R_c^T \\
 \boldsymbol{t} &= -RC 
\end{align}
\]
</div>

<h3>The "Look-At" Camera</h3> 
Readers familiar with OpenGL might prefer a third way of specifying the camera's pose using *(a)* the camera's position, *(b)* what it's looking at, and *(c)* the "up" direction.  In legacy OpenGL, this is accomplished by the gluLookAt() function, so we'll call this the "look-at" camera.  Let *C* be the camera center, ***p*** be the target point, and ***u*** be up-direction.   The algorithm for computing the rotation matrix is (paraphrased from OpenGL documentation TODO-Link here):

1. Compute L = p - C.
2. Normalize L.
3. Compute s = L x u. (cross product)
4. Normalize s.
5. Compute u' = s x L.

The extrinsic matrix's rotation matrix is then given by:

<div>
\[
R = \left( 
\begin{array}{ccc}
s_1 & u_1^' & L_1 \\
s_2 & u_2^' & L_2 \\
s_3 & u_3^' & L_3 \\
\end{array}
\right)
\]
</div>

You can get the translation vector the same way as before, ***t** = -RC*.

<h2>Intrinsic Matrix</h2>
<p>
    The intrinsic parameters represent the camera's internal geometry.    Alternatively, they can be thought of as 2D transformations whereas extrinsic parameters affect 3D transformations.  As you change the intrinsic parameters, watch the left pane and notice that the camera (blue cube) doesn't move, only the viewing volume does.  Also note how the captured image in the right pane changes: the spheres can grow, move and distort, but their size, shape, and position relative to one-another is unchanged.  
</p>

<div class="demo_3d">
    <div id="3d_container" >
    </div>
    <div class="caption"><em>Left:</em>: scene with camera and viewing volume.  Virtual image plane is shown in yellow.   <em>Right</em>: camera's image.  Adjust camera parameters with sliders below.</div>
    <div id="extrinsic-controls">
    </div>
    <div id="intrinsic-controls">
        <div class="slider-control">
            <div class="slider" id="focal_slider">
            </div>
            <div class="slider-label">
            Focal Length
            </div>
            <div class="clearer"></div>
        </div>
        <div class="slider-control">
            <div class="slider" id="skew_slider">
            </div>
            <div class="slider-label">
            Axis Skew 
            </div>
            <div class="clearer"></div>
        </div>
        <div class="slider-control">
            <div class="slider" id="x0_slider">
            </div>
            <div class="slider-label">
            \(x_0\)
            </div>
            <div class="clearer"></div>
        </div>
        <div class="slider-control">
            <div class="slider" id="y0_slider">
            </div>
            <div class="slider-label">
            \(y_0\)
            </div>
            <div class="clearer"></div>
        </div>
    </div>

</div>
